[toc]
```
作者：Augenstern_3
链接：https://www.nowcoder.com/discuss/593554
来源：牛客网
```
1. 你这个项目的QPS、订单量有多少
1. 如何解决超卖问题
1. 假如让你设计一个秒杀系统，怎么设计才能承受百万级并发
1. Redis也扛不住了，万级流量会打到DB上，该怎么处理
1. 分库分表怎么设计
1. 水平分表依据什么分？时间还是数据
1. 分库分表之后我想查询近期的订单，怎么查
1. 数据存储引擎有哪些
1. InnoDB和MylSAM的区别
1. select count(*)时InnoDB和MylSAM分别是怎么处理的
1. 聚簇索引和非聚簇索引的区别
1. 假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？反过来呢？
1. 事务有哪些隔离级别，分别解决了什么问题
1. 可重复读是怎么解决脏读的
1. 有俩事务，事务A：读、写(张三)、读    事务B：读、写(李四)、读，假如俩事务同时执行，结果如何
1. Redis有哪5种数据类型
1. Set、Zset分别用于哪些场景
1. Redis是怎么删除过期key的
1. Redis有哪些持久化方式
1. 你用过哪些队列
1. 说一下AMQP协议是怎么定义一个MQ的
1. 交换机有哪些消息转发模式（大体是这个意思）
1. HTTPS工作原理


###### 1. QPS、订单量有多少
```
QPS --每秒请求量
--有效承保数据
```
###### 2. 如何解决超卖问
```
秒杀引起超卖问题
场景描述:只剩一个商品，库存num=1;
但是100 个线程同时读到 num=1,所以100个线程同时开始减一
最终 99个失败 ，一个成功
第一种解决方案

 update goods set num = num - 1 WHERE id = 1001 and num > 0

mysql 排他锁又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁,其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。类似于执行update 操作时，这一行是一个事务（默认加了排他锁）。这一行不能被任何线程修改和读写

第二种解决超卖方式

select version from goods where id =1001
update goods set num =num -1 ,version = version +1 where id = 1001 and num > 0 and version =@version(上面查到的version);

采用版本号方式，即CAS原理

第三种解决方式如下

利用redis单线程预减库存。比如商品100件，redis 存储<gs1001,100>
每一个用户线程进来，key值就减一，等减到0的时候，全部拒绝剩下的请求。


```
###### 3.假如让你设计一个秒杀系统，怎么设计才能承受百万级并发
```
https://www.zhihu.com/question/54895548
https://www.cnblogs.com/sanluorenjian/p/9867311.html

设计理念
限流： 鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。 --答题验证，识别码等

削峰：对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思路。实现削峰的常用的方法有利用缓存和消息中间件等技术。

异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。

内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。 ----单体redis 4w qps 做集群，采用哨兵模式

可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。


方案：
前端：
页面静态化：通过CDN来抗峰值。 
禁止重复提交;
用户限流：在某一时间段内只允许用户提交一次请求，比如可以采取IP限流

后端方案
服务端控制器层(网关层) 
限制uid（UserID）访问频率：我们上面拦截了浏览器访问的请求，但针对某些恶意攻击或其它插件，在服务端控制层需要针对同一个访问uid，限制访问频率。
nginx 负载均衡

服务层
上面只拦截了一部分访问请求，当秒杀的用户量很大时，即使每个用户只有一个请求，到服务层的请求数量还是很大。比如我们有100W用户同时抢100台手机，服务层并发请求压力至少为100W。
令牌桶算法限流
Hystrix进行服务熔断和降级

采用消息队列缓存请求：既然服务层知道库存只有100台手机，那完全没有必要把100W个请求都传递到数据库啊，那么可以先把这些请求都写到消息队列缓存一下，数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束。

利用缓存应对读请求：对类似于12306等购票业务，是典型的读多写少业务，大部分请求是查询请求，所以可以利用缓存分担数据库压力。

利用缓存应对写请求：缓存也是可以应对写请求的，比如我们就可以把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。
数据库层
数据库层是最脆弱的一层，一般在应用设计时在上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。
```

###### 4.Redis也扛不住了，万级流量会打到DB上，该怎么处理
###### 5.分库分表怎么设计?水平分表依据什么分？时间还是数据
```
数据库读写分离 多读
分库分表
垂直- 业务划分
水平- group-range-tab  按照时间容易出现热数据，无法保证平均 ，按照数据id 
```

###### 6.分库分表之后我想查询近期的订单，怎么查
```
双写 
用户-订单表
商家-订单表

es
```
###### 7.InnoDB和MylSAM的区别
```
1.事务处理
my是非事务安全型，in是事务安全型
2.锁机制不同
my是表级锁，in是行级锁
3.select ,update,insert,delete 操作
my:执行大量的select
in:大量insert或update,出于性能安全考虑 in
4.查询表的行数不同：
my: cout(*)只需读出保存好的行数
in:全表扫描
5.支持外键：
my：no in:支持
```
###### 8.select count(*)时InnoDB和MylSAM分别是怎么处理的
```
INNODB在做SELECT的时候，要维护的东西比MYISAM引擎多很多；
1）数据块，INNODB要缓存，MYISAM只缓存索引块，  这中间还有换进换出的减少； 
2）innodb寻址要映射到块，再到行，MYISAM 记录的直接是文件的OFFSET，定位比INNODB要快
3）INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护
MVCC ( Multi-Version Concurrency Control )多版本并发控制 
```
###### 9.聚簇索引和非聚簇索引的区别
```
聚集索引。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。
非聚集索引。表数据存储顺序与索引顺序无关。

innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值 ---回表
```

###### 10.假如数据库某个字段是String类型，读的时候用int类型去接收会有什么问题？反过来呢？
```
int -
```