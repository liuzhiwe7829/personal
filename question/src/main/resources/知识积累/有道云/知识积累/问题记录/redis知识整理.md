[toc]
#### 5.3 分布式数据库
##### 5.3.1 redis
###### 1. redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高?
```
区别:
1.mc可缓存图片和视频。rd支持除k/v更多的数据结构;
2.rd可以使用虚拟内存，rd可持久化和aof灾难恢复，rd通过主从支持数据备份;
3.rd可以做消息队列
原因:mc多线程模型引入了缓存一致性和锁，加锁带来性能损耗
```
###### 2. redis主从复制如何实现？redis集群模式如何实现？redis的key如何寻址?
###### 3. 使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？两种有什么区别？
```
reeis
1.线程A setnx(上锁的对象，超过时的时间戳t1),如果返回true,或者锁。
2.线程B 用get获取t1,与当前时间戳比较，判断是否超时，没超时false,若超时执行3
3.计算新的超时时间t2，使用getset命令返回t3(该值可能其他线程已经修改过)，如果t1==t3,获得锁，如果t1!=t3说明锁被其他线程获取。
4.获取锁后，处理完业务逻辑，再去判断锁是否超时，人说过没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）。

zk:
1.客户端对某个方法加锁时，在zk上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点node1;
2.客户端获取该路径下已经创建的子节点，如果发现自己创建的的node1的序号是最小的，就认为这个客户端获得了锁。
3.如果发现node1不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。比如 A 001 B 002 则监听 001 
4.获取锁后，处理完逻辑，删除自己创建的node1即可。
区别：zk性能差一些，开销大，实现简单

```
###### 4. redis持久化嘛？底层如何实现？有什么优点缺点？
```
RDB(Redis DataBase:在不同的时间点将redis的数据生成的快照同步到磁盘等介质上):内存到硬盘的快照，定期更新。
缺点:耗时，耗性能(fork+io操作),易丢失数据。
AOF(Append Only File:将redis执行过的所有指令都记录下来，在下次redis重启是，只需要执行指令就可以):写日志。
缺点：体积大，恢复速度慢。
bgsave作镜像全量持久化，aof做增量持久化。因为bgsave会消耗比较长时间，不够实时，在停机的时候会导致大量的数据丢失，需要aof来配合，在redis实例重启时，有限使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复。Redis会定期做aof重写，压缩aof文件日志大小。Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的速率又兼顾了数据的安全性。bgsave的原理，fork和cow,fork是指reids通过创建子进程来进行bgsave操作，cow指的是copY on write ，子进程创建后，父子进程共享数据，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。
```


###### 5. redis过期策略都有哪些？LRU算法？写一下java代码实现？
```
过期策略：
定时过期（一key一定时器），
惰性过期:只是用key时才判断key是否已过期，过期则清除。
定期过期：前两者折中。

LRU:new LinkedHashMap<K,V>(capatity,DEFAULT_LODA_FACTORY,true);
//第三个参数为true,代表linkedList按访问顺序排序，可作为LRU缓存;
设为false 代表 按插入顺序安排,可作为FIFO缓存

LRU 算法实现:
1.通过双向链表来实现，新数据插入到链表头部;
2.每当缓存命中(即缓存 数据被访问),则将数据一到链表头部;
3.当链表满的时候，将链表尾部的数据丢失。
LinkedHashMap:HashMap 和双向链表合二为一即是LinkedHashMap。
HashMap是无序的，LinkedHashMap通过维护一个额外的双向链表保证了迭代顺序。改迭代顺序可以是查询顺序，也可以是访问顺序。

```

###### 6. 缓存穿透、缓存击穿、缓存雪崩解决方案？
```
缓存穿透:查询一个一定不存在的数据，如果从缓存存储层查不到数据则不写入缓存，这将导致这个数据每次请求都要到DB去查询，可能导致db挂掉。

解决方案:
1.查询返回数据为空，扔把这个空结果进行缓存，单过期时间会比较短;
2.布隆过滤去:将所有可能存在的数据哈希到一个足够大的bitmap中,一个一定不存在的数据会被bitmap拦截掉，从而避免对db的查询。


缓存击穿：对于设置了过期时间的key,缓存在某个时间点过期的时候，恰好这个时间点对这个kdy有大量的并发请求，请求发现缓存过期一般都会从后端DB加载数据并回写缓存，这个场子大并发的请求可能会瞬间把DB压垮。

解决方案：
1.使用互斥锁：当缓存失效是，不立即去load db<先使用如Redis的setntx去设置一个互斥锁，当操作成功返回时进行load db的操作并回设缓存，否则重试get缓存的方法。
2.永远不过期:物理不过期，单逻辑过期后（后台异步线程去刷新）。

缓存雪崩：设置缓存采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB,DB瞬时压力过重雪崩。

与缓存击穿的区别:雪崩是很多key,击穿是某一个key缓存

解决方案：将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分支随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发机器失效事件。

```

###### 7. 在选择缓存时，什么时候选择redis,什么时候选择memcached
```
选择redis情况
1.复杂的数据结构，value的数据是hash，列表，集合，有序集合等这种情况下，选择redis，因为memcache无法满足这些数据结构，最典型的使用场景是，用户订单列表，用户消息，帖子评论等。
2.需要进行数据持久化功能，但是注意，不要把redis当成数据库使用，如果redis挂了，内存能够快速回复热数据，不会将压力试验压在数据库上，没有cache预热的过程。对于制度和数据一致性要求不高的场景可以才有持久化存储。
3.高可用，redis 支持集群，可以实现主动复制，读写分离，而对于memcache如果想要实现高可用，需要进行二次开发。
4. 存储的内容比较大，memcache存储的value最大为1M.



选择memcache的场景
1.纯kv，数据量非常大的业务，使用me更合适，原因是，
 1.1.me内存分配采用的是预分配内存池管理方式，能够省去内存分配的时间，redis是临时申请空间，可能导致碎片化。
 1.2虚拟内存使用，me将所有的数据存储在物理内存里，redis有自己的vm机制，理论上能够存储比物理内存更多的数据，当数据超时是，引发swap，把冷数据刷新到磁盘上，从这点上，数据量大时，me更快
 1.3 网络模型，me使用非阻塞的io复用模型，redis也是使用非阻塞的IO复用模型，但是redis还是提供了一些非kv存储之外的排序，聚合功能，复杂的cpu计算，会阻塞整个io调度，从这点上由于redis提供的功能较多，me更快些。
 1.4 线程模型，me使用多线程，主线程监听，worker子线程接受请求，执行读写，这个过程可能存在锁冲突。redis使用的单线程，虽然无锁冲突，但是难以利用多核的特性提升吞吐量。
```
###### 8.缓存与数据库不一致怎么办
```
注册分离，读写分离的数据库

线程A先删除缓存数据，然后将数据写入到主库当中，这个时候，主库和从库同步没有完成，线程B从缓存当中读取数据失败，从从库中读取到旧数据，然后更新至缓存，这个时候，缓存当中的就是旧的数据。

发生上述不一致原因在于，主从库数据不一致问题，加入缓存后主从不一致时间被拉长了。

解决方案：
从库有数据更新之后，将缓存当中的数据也同时进行更新，即当从库发生了数据更新之后，向缓存发出删除，淘汰这段时间写入的旧数据。

```

###### 9.主从数据库不一致如何解决
```
场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致
1.忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致。
2.强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。
3.选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，那张表，哪个主键，作为缓存的key，设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。
```
###### 10.Redis 常见的性能问题和解决方案
```
1.master 最好不要做持久化工作，如RDB内存快照和AOF日志文件
2.如果数据比较重要，某个slave开启AOF备份，策略设置成每秒同步一次
3.为了主从复制的速度和连接的稳定性，master和slave最好在一个局域网内
4.尽量避免在压力打的主库上增加从库
5.主从复制不要采用网状结构，尽量是线性结构，
```