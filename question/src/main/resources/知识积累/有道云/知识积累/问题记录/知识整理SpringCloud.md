[toc]
##### 1.什么是SpingCloud ?
```
SpringCloud 基于SpringBoot 的Spring集成应用程序。SpringCloudTask,一个生命周期暂短的微服务框架,用于快速构建程序。
```
##### 2.使用SpringCloud 有什么优势
```
使用SpringBoot开发分布式微服务时，面临以下问题
1.与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，宽带问题，安全问题等
2.服务发现
3.冗余-分布式系统中的冗余问题
4.负载均衡-
5.性能问题 各种运营开销导致的性能问题
6.部署复杂性-Devops技能的要求。
```
##### 3.服务注册和发现是什么意思？SpringCloud 如何实现？
##### 4.负载均衡的意义？
##### 5.什么是hystrix?如何实现容错
```
Hystrix定义一个回退方法 Fallback,这个方法具有与正常服务相同的返回类型。如果暴露服务中出现异常，则回退方法返回一些值。
```
##### 8.什么是SpringCloud bus ？我们需要它么？
```
多个应用程序使用Spring Cloud Config读取属性
而Spring Cloud Config从git读取这些属性。 
Spring Cloud Bus 提供跨多个实例刷新配置的功能。
服务配置修改不用重启。
```
#### 2.SpringBoot
##### 1.什么是SpringBoot?
##### 2.SpringBoot优点?
```
减少开发，测试时间和精力
使用JavaConfig有助于避免使用XML
避免大量Maven导入和各种版本冲突
没有单独的web服务器需要，意味着不用启动tomcat
需要少量配置，因为没有web.xml文件。只需要添加@Configuration注释类，然后添加@bean注释方法
```
##### 3.什么是javaConfig?
```
SpringJavaConfig 是Spring社区的产品，提供了配置SpringIoC容器的纯java方法。因此它有助于避免使用XML配置。
使用JavaConfig优点在于:
面向对象配置。由于配置被定义为javaConfig中的类，因此用户可以充分利用java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。
减少或消除XML配置。
```
##### 4.如何重新加载SpringBoot上的更改，而无需重新启动服务器？
```
可以使用DEV工具来实现。通过依赖关系，节省任何更改，嵌入式tomcat将重新启动。SpringBoot有一个开发工具（DevTools）模块，它有助于提供开发人员的生产力。
```
##### 5.SpringBoot中的监视器是什么？
```
SpringBootActuator是Spring启动框架中的重要功能之一。SpringBoot监视器可以帮助访问生产环境中正在运行的应用程序的当前状态。
```
##### 6.如何在SpringBoot中禁用Actuator端点安全性?
```
management.security.enabled = false
```
##### 9.如何实现SpringBoot应用安全性？
```
spring-boot-starter-security依赖项,并且必须添加安全配置。只需要很少的代码。配置类将必须拓展
WebSecurityConfigurerAdapter并覆盖其方法
```
##### 12.什么是Swagger？
```
可视化API
```

##### 13.什么是Spring Profiles?
```
Spring Profiles 允许用户根据配置文件（dev,test,prod等）来注册bean。
```
##### 14.什么是Spring Batch？
```
Spring Boot Batch 提供可重用的函数，这些函数在待处理大量记录时非常重要，宝控日志、跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。简单以及复杂的大批量批处理作业。
```
##### 15.什么是FreeMarker模板》
```
基于java的模板引擎，最初专注于使用MVN软件架构进行动态网页生成。使用Freemarker的主要优点是标识层和业务层的完全分离。
```
##### 16.如何使用SpringBoot实现异常处理？
```
Spring提供了一种使用ControllerAdvice处理异常的的非常有用的方法。我们通过实现一个ControlerAdvice类，来处理控制器类抛出的所有异常。
```
##### 17.使用过哪些starter maven依赖项？
```
spring-boot-starter-activemq |security
```
##### 19.什么是webSockects?
```
计算机通信协议，通过单个TCP连接提供全双工信道。WebSocket是双向的-使用WebSocket客户端或服务器可以发起消息发送。
```
##### 20.什么是AOP
```
跨越应用程序多个点的功能称为交叉问题。这些交叉问题与应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向切面编程。
```
##### 21.什么是Apache Kafka?
```
分布式发布-订阅消息系统。
```
#### 3.Dubbo
##### 1.dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者还能通信么？
```
本地缓存
```
##### 2.dubbo 负载聚合策略
```
1.随机
2.轮询
3.最少活跃调用数
4.一致性hash
```
##### 3.dubbo在安全机制方面如何解决
```
dubbo 通过token 令牌防止用户绕过注册中心直连，然后再注册中心上管理授权。dubbo还提供服务黑名单，来控制服务所允许的调用方
```
##### 4.dubbo连接注册中心和直连的区别
```
开发:绕过注册中心，只测试指定服务提供者，有时候需要点对点直连
```
##### 5.dubbo服务集群配置（集群容错模式）
```
集群调用失败是，dubbo提供了多种容错方案，缺省为failover重试。
1 failover Cluster(默认)
失败自动切换，当出现失败，重试其他服务器。（缺省）通常用于读操作，重试会带来更长延迟。可通过retries="2"设置重试次数（不含第一次）。
```
##### 6.dubbo通信协议dobbo协议为什么要消费者比提供者个数多？
```
因为dubbo协议采用单一长链接，假设网络为千兆网卡，工具测试每条了解最多只能压满7mbyte。理论上一个服务提供者需要20个服务消费者才能压满网卡
```
##### 7.通信协议dubbo为什不能传大包？
```

```
##### 8.dubbo通信协议为什么采用异步单一长链接？
```
因为服务的现状大都是服务提供者少，消费者多。
如果采用常规的hessian服务，服务提供者很容易压垮，通过单一连接，保证单一消费者不会压垮提供者
```
##### 9.dubbo协议使用范围和场景
```
传入参数数据包较小，消费者比提供者多，单一消费者无法压满提供者，尽量不用dubbo协议传输大文件或超大字符串。适用场景:常规远程服务方法调用
TCP传输方式 ：NIO异步
传输序列化：hessian二进制
```
##### 10.RMI协议
```
RMI协议采用JDK标准的java.rmi.*实现，采用阻塞式短连接和jdk标准序列化方式，java标准的远程调用协议。
适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。
```
##### 11.Hessian协议
```
底层采用Http通讯，从用Servlet暴露服务，dubbo缺省内嵌jetty作为服务器实现。
Hessian二进制序列化适用范围:传入传出参数叔叔包较大，提供者比消费者个数多，提供者压力较大，可传文件。
适用场景：页面传输，文件传输
```
##### 12 http
```
http采用Spring的HttpInvoker失效。基于http表单的远程调用协议。
连接个数：多连接
连接方式：短连接
传输协议：http
传输方式：同步传输
序列化：表单序列化JSON
适用范围
```
#### 3.并发编程高级
##### 1.Synchronized 其原理是什么?
```
Synchronized是由JVM实现的一种实现互斥同步的一种方式，被Synchronized修饰过的程序块，在编译前后被编译器生成了monitornerter和monitorexit两个字节码指令。在虚拟机执行到monitorenter指令时，首先要尝试获取对象的锁:如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器+1;当执行monitorexit指令时将锁计数器-1;当计数器为0时，锁就呗释放了。如果获取对象失败，那当前线程就阻塞等待，直到对象锁被另外一个线程释放为止。java中Synchronize通过在对象头设置标记，达到了获取锁和释放锁的目的。
```
##### 2.锁是什么？如何确定对象的锁？
```
本质是monitorenter和monitorexit字节码指令的一个Reference类型参数，即要锁定和解锁的对象。使用Synchronized可以修饰不同的对象，因此，对应的对象锁可以这么确定。
1.如果Synchronized明确指定了锁对象，比如Synchronized(变量名),Synchronized(this)等，说明加解锁对象为该对象。
2.如果没有明确指定：
    若Synchronized修饰的方法为非静态方法，标识此方法对应的对象为锁对象。
    若Synchronized修饰的方法为静态方法，则标识此方法对应的类对象为锁对象。
注意，当一个对象被锁住时，对象里所有用Synchronized修饰的方法都将产生堵塞，而对象里非Synchronized修饰的方法可正常被调用，不受锁影响。

```
##### 3.什么是可重入性，为什么说Synchronized是可重入锁？
```
可重入性是锁的一个基本要求，是为了解决自己锁死自己的情况。一个类中的同步方法调用另一个同步方法，假如Synchronized不支持重入，进驻method2方法时当前线程获得锁，method2方法里执行method1时当前线程又要尝试获取锁，如果不支持重入，就要等待释放，把自己阻塞，导致自己锁死自己。对于Synchronized指令，如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，就会把锁计数器+1，本质通过这种方式实现了可重入性。
```
##### 4.JVM 对Java 的原生锁做了哪些优化？
```
在java5之前，Monitor的实现完全依赖底层操作系统的互斥锁来实现，也就是我们刚才在问题二中所阐述的获取/释放锁的逻辑。
现在jdk中提供了三种不同的Monitor实现，三种不同的锁：
偏向锁（Biased Locking）
轻量级锁
重量级锁

这三种锁使得JDK得以优化Synchronized的运行，当JVM检测到不同的竞争状态时，会自动切换到适合的锁实现，这就是锁的升级，降级。

当没有竞争出现时，默认会使用偏向锁

jvm会利用CAS操作，在对象头上的MarkWord部分设置线程ID,以表示这个对俩偏向于当前线程，所以并不涉及真正的互斥锁，因为在很多应用场景中，大部分对象生命周期最多会被一个线程锁定，使用偏向锁可以降低竞争开销。

如果有另一线程视图锁定某个被偏斜过的对象，jvm就撤销偏斜锁，切换到轻量级锁实现。

轻量级锁依赖CAS操作MarkWord来试图获取锁，如果重试成功，就使用普通的轻量级锁;否则，进一步升级为重量级锁。
```
##### 5.Synchronized是非公平锁？
```
非公平锁主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，没当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象
```
##### 6.什么是锁消除和锁粗化？
```
锁消除:指虚拟机及时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。

锁粗化:原则上，同步块的的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁的进行胡扯同步猜错也会导致不必要的性能损耗。
锁粗化就是增大锁的作用域。
```
##### 7.为什么说Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？
什么是CAS,它有什么特性？
```
Synchronized 显然是一个悲观锁，因为它的并发策略是悲观:
不管是否会产生竞争，任何的数据操作都要被唤醒等操作。随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。


乐观锁核心算法：

CAS涉及到三个操作数：内存值，预期值，新值。当且仅当预期值和内存值相等时才将内存值修改为新值。这样的处理逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，如果卜一祥则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否者说明期间没有其他线程对此内存操作，可以把心智设置给此内存。

CAS具有原子性，它的原子性由CPU硬件指令实现保证，即使用JNI调用Native方法调用由C++编写的硬件级别指令，jdk提供了unsafe类执行这些操作。
```


##### 8.乐观锁一定时好的吗？
```
乐观锁避免了悲观锁独占现象。但也有缺点
1.乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。
2.长时间自旋可能导致开销大。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。
3.ABA问题。CAS的核心思想是通过对比内存值与预期值是否一样儿判断内存是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A,则CAS认为此内存值并没有发生改变，但实际上是由被其他线程改过的，这种情况依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一
```
##### 9.跟Synchronized相比，可重入锁ReentrantLock其实现原理有什么不同？
```
其实，锁的实现原理基本是为了达到一个目的:
让所有的线程都能看到某种标记。

Synchronized通过在对象头中设置标记实现这一目的，是一种jvm原生的锁实现方式，而ReentrantLock以及所有的基于Lock接口的实现类，都是通过用一个volitile修饰的int型变量，并保证每个线程都能拥有对该int的可见性和原子性修改，其本质是基于所谓的AQS框架。
```

##### 10.AQS框架是什么
```
AQS(AbstractQueuedSynchronizer类)是一个用来构建锁和同步器的框架，各种Lock包中的锁（常用的有ReentrantLock、ReadWriteLock）,以及其他如Semaphore,CountDownLatch,甚至早起的FutureTask等，都是基于AQS来构建。

1.AQS在内部定义了一个volitile int state变量，标识同步状态：当线程调用lock方法是，如果state=0,说明没有任何线程占有共享资源的锁，可以获得锁并将state=1;如果state=1,则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。
2.AQS通过Node内部类构成一个双向链表结构的同步队列，来完成线程锁去锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。
Node 类是对要访问同步代码的线程的封装，包含到了线程本身及其状态 waitStatus(有五种不同取值，分别表示是否被阻塞，是否呆呆唤醒，是否已经被取消等)，每个Node节点关联其pre节点和netxt节点，方便线程释放锁后快速唤醒下一个在等待的ex名称，是一个FIFP的过程。

Node类有两个常量，SHARED和EXCLUSIVE,分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线程同时操作(信号量Semaphore就是基于AQS的共享模式实现的),独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待（如ReentranLock）
```






























































